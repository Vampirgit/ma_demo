//! Implementation of simulated clients/users

use std::iter::Peekable;

use crate::observer::ClientObserver;
use crate::user::{Request, UserModel};

use tor_circuit_generator::CircuitGenerator;
use tordoc::{consensus::Flag, Fingerprint};

use chrono::prelude::*;
use chrono::Duration;
#[allow(unused_imports)]
use log::{debug, info, trace, warn};

use lazy_static::lazy_static;

lazy_static! {
    static ref MAX_CIRCUIT_DIRTINESS: Duration = Duration::minutes(10);
    static ref CIRCUIT_IDLE_TIMEOUT: Duration = Duration::minutes(60);
    static ref LONG_LIVED_PORTS: Vec<u16> =
        [21, 22, 706, 1863, 5050, 5190, 5222, 5223, 6523, 6667, 6697, 8300]
            .into_iter()
            .collect();
}

/// A simulated Tor client.
///
/// This implements Tor's behavior of handling circuits, streams, etc. for
/// handling the requests made by a user, as modelled by a given `UserModel`.
pub(crate) struct Client<U: UserModel> {
    id: u64,
    observer: ClientObserver,
    user_model: Peekable<U>,
    circuit_manager: CircuitManager,
}

impl<U: UserModel> Client<U> {
    /// Construct a new Client
    pub(crate) fn new(id: u64, user_model: U) -> Client<U> {
        Client {
            id,
            observer: ClientObserver::new(id),
            user_model: user_model.peekable(),
            circuit_manager: CircuitManager::new(),
        }
    }

    /// Called from outside when the simulation enters a new epoch,
    /// with a new consensus being available.
    /// TODO: Clarify what an epoch is
    pub(crate) fn handle_new_epoch(
        &mut self,
        epoch_start: &DateTime<Utc>,
        epoch_end: &DateTime<Utc>,
        circuit_generator: &CircuitGenerator,
    ) -> anyhow::Result<()> {
        // TODO: period_client_update
        // TODO: update guard set

        // TODO: cover uncovered ports while fewer than
        // TODO: TorOptions.max_unused_open_circuits clean

        // Do time-based maintaining at least once per epoch
        self.circuit_manager
            .timed_client_updates(&epoch_start, circuit_generator)?;

        // construct all the circuits in this time frame
        loop {
            // Look at the next request, but do not consume it yet
            let next = self.user_model.peek();

            let request = match next {
                Some(x) if (&x.time >= epoch_start && &x.time < epoch_end) => {
                    // use/consume this request element and advance the user model
                    self.user_model.next().unwrap() // cannot fail as peek() was Some(_)
                }
                _ => break,
            };

            // Do time-based maintaining. TorPS does this once per minute but it
            // **should** be ok to do this only when actually needed.
            // TODO: Maybe this is not true anymore when we introduce need covering
            self.circuit_manager
                .timed_client_updates(&request.time, circuit_generator)?;

            self.circuit_manager
                .handle_request(request, circuit_generator, &mut self.observer)?;
        }

        Ok(())
    }

    /// Get the client's ID
    pub(crate) fn get_id(&self) -> u64 {
        self.id
    }

    /// Finish this client and return its observer
    pub(crate) fn into_observer(self) -> ClientObserver {
        self.observer
    }
}

/// A Tor circuit defined only by its relays' fingerprint, not tied to a consensus.
///
/// We use this to persist circuits over different consensuses, without needing
/// to keep track of the consensus itself. This also makes sure we do not
/// accidentally use stale consensus information of the relays at some point.
#[derive(Clone, Debug)]
pub(crate) struct ShallowCircuit {
    pub guard: Fingerprint,
    pub middle: Fingerprint,
    pub exit: Fingerprint,
    // TODO: do we need to remember exit policy, ports, etc.?
    /// Time when this circuit was created
    time: DateTime<Utc>,
    /// Time the circuit became "dirty". If this is None, circuit is clean.
    dirty_time: Option<DateTime<Utc>>,
    /// Is this circuit intended for name resolution and onion services only?
    is_internal: bool,
    /// Is this circuit expected to have only stable relays?
    is_stable: bool,
    /// Is this circuit expected to have only fast relays?
    is_fast: bool,
}

impl ShallowCircuit {
    /// Construct from a circuit as generated by the CircuitGenerator
    fn from_generated_circuit(
        circgen_circuit: tor_circuit_generator::TorCircuit,
        stable: bool,
        fast: bool,
        time: DateTime<Utc>,
        dirty_time: Option<DateTime<Utc>>,
    ) -> ShallowCircuit {
        if circgen_circuit.middle.len() != 1 {
            panic!("We only support 3-hop circuits at the moment");
        }
        ShallowCircuit {
            guard: circgen_circuit.guard.fingerprint.clone(),
            middle: circgen_circuit.middle[0].fingerprint.clone(),
            exit: circgen_circuit.exit.fingerprint.clone(),
            time,
            dirty_time,
            is_internal: false,
            is_stable: stable,
            is_fast: fast,
        }
    }

    /// Check if this circuit can accommodate a given stream request.
    ///
    /// # Panics
    ///
    /// _May_ panic if the circuit's relays aren't part of the consensus.
    fn supports_stream(&self, request: &Request, circgen: &CircuitGenerator) -> bool {
        if !self.is_internal {
            return false;
        }

        if !self.is_stable && LONG_LIVED_PORTS.contains(&request.port) {
            return false;
        }

        let exit = circgen.lookup_relay(&self.exit).unwrap();
        if !(*exit).exit_policy.allows_port(request.port) {
            return false;
        }

        true
    }
}

/// A container for circuits currently maintained by the client
struct CircuitManager {
    // TODO:
    // - dirty circuits
    // - clean circuits
    //
    //
    /// Circuits that have already been constructed (both, clean & dirty)
    circuits: Vec<ShallowCircuit>,
}

impl CircuitManager {
    /// Construct a new circuit manager from scratch for a new client
    fn new() -> CircuitManager {
        CircuitManager {
            circuits: Vec::new(),
        }
    }

    /// When entering a new epoch, carry out the housekeeping of currently
    /// maintained circuits, etc.
    fn timed_client_updates(
        &mut self,
        time: &DateTime<Utc>,
        circgen: &CircuitGenerator,
    ) -> anyhow::Result<()> {
        // remove old circuits
        self.circuits.retain(|circuit| match circuit.dirty_time {
            Some(dirty_time) => {
                // dirty circuits
                return dirty_time + *MAX_CIRCUIT_DIRTINESS >= *time;
            }
            None => {
                // clean circuits
                return circuit.time + *CIRCUIT_IDLE_TIMEOUT >= *time;
            }
        });

        // remove circuits whose relays have gone missing
        self.circuits.retain(|circuit| {
            for relay in [&circuit.guard, &circuit.middle, &circuit.exit] {
                match circgen.lookup_relay(relay) {
                    None => {
                        return false;
                    }
                    Some(x) => {
                        // TODO: check old hibernating flag from descriptor
                        if !(x.flags.contains(&Flag::Running)) || !(x.flags.contains(&Flag::Valid))
                        {
                            return false;
                        }
                    }
                }
            }
            true
        });

        Ok(())
    }

    /// Try to accommodate a stream request, using the existing circuits etc.
    fn handle_request(
        &mut self,
        request: Request,
        circgen: &CircuitGenerator,
        observer: &mut ClientObserver,
    ) -> anyhow::Result<()> {
        // Unfortunately, we have to split the following two criteria into
        // separate functions to work around one of the current
        // limitations of the borrow checker.
        //
        // See https://blog.rust-lang.org/2022/08/05/nll-by-default.html#looking-forward-what-can-we-expect-for-the-borrow-checker-of-the-future
        // This limitation keeps us from writing the two mutable loops (with early return)
        // in a single function.

        // first check if a dirty circuit is usable
        let mut chosen_circ = self.get_suitable_dirty_circuit(&request, circgen);

        // check if a clean circuit is usable
        if chosen_circ.is_none() {
            chosen_circ = self.get_suitable_clean_circuit(&request, circgen);
        }

        // otherwise, make a new circuit
        if chosen_circ.is_none() {
            let need_stable = LONG_LIVED_PORTS.contains(&request.port);
            let need_fast = true;

            let circuit = circgen
                .build_circuit_with_flags(3, request.port, need_fast, need_stable)
                .map_err(|e| anyhow::anyhow!(format!("{:?}", e)))?;
            observer.notify_new_circuit(request.time, &circuit, request.port);
            self.circuits.push(ShallowCircuit::from_generated_circuit(
                circuit,
                need_stable,
                need_fast,
                request.time.clone(),
                Some(request.time.clone()),
            ));
            chosen_circ = self.circuits.last();
        }
        let chosen_circ = chosen_circ.unwrap(); // cannot fail as the if block adds an element if there was none
        observer.notify_circuit_used(chosen_circ, &request);

        Ok(())
    }

    /// Select an existing **dirty** circuit that is suitable for handling a given stream request
    fn get_suitable_dirty_circuit(
        &mut self,
        request: &Request,
        circgen: &CircuitGenerator,
    ) -> Option<&ShallowCircuit> {
        for circ in self.circuits.iter_mut() {
            if let Some(dirty_time) = circ.dirty_time {
                if request.time < dirty_time + *MAX_CIRCUIT_DIRTINESS
                    && circ.supports_stream(&request, circgen)
                {
                    return Some(circ);
                }
            }
        }
        None
    }

    /// Select an existing **clean** circuit that is suitable for handling a given stream request
    fn get_suitable_clean_circuit(
        &mut self,
        request: &Request,
        circgen: &CircuitGenerator,
    ) -> Option<&ShallowCircuit> {
        for circ in self.circuits.iter_mut() {
            if circ.dirty_time.is_none() {
                if circ.supports_stream(&request, circgen) {
                    // make this circuit dirty
                    // TODO make sure we check somewhere else circuit_idle_timeout
                    // TODO Do we maybe have to reorder the circuits? TorPS uses .appendleft()
                    circ.dirty_time = Some(request.time.clone());
                    // TODO reduce cover count for covered port needs
                    return Some(circ);
                }
            }
        }

        None
    }
}
